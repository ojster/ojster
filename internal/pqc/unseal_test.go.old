// // Copyright 2026 Jip de Beer (Jip-Hop) and ojster contributers
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     https://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.

// package pqc

// import (
// 	"crypto/mlkem"
// 	"encoding/base64"
// 	"fmt"
// 	"io"
// 	"os"
// 	"path/filepath"
// 	"strings"
// 	"testing"

// 	"github.com/ojster/ojster/internal/common"
// 	"github.com/ojster/ojster/internal/testutil"
// )

// func tmp(t *testing.T, name string) string {
// 	t.Helper()
// 	return filepath.Join(t.TempDir(), name)
// }

// func write(t *testing.T, path, content string) {
// 	t.Helper()
// 	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
// 		t.Fatalf("write %s: %v", path, err)
// 	}
// }

// func captureStdout(t *testing.T, f func()) string {
// 	t.Helper()
// 	old := os.Stdout
// 	r, w, _ := os.Pipe()
// 	os.Stdout = w

// 	f()

// 	w.Close()
// 	os.Stdout = old
// 	out, _ := io.ReadAll(r)
// 	return string(out)
// }

// // --- success ---------------------------------------------------------------

// func TestUnseal_SuccessEnv(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")

// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake-priv")))

// 	ct := base64.StdEncoding.EncodeToString([]byte("cipher"))
// 	gcm := base64.StdEncoding.EncodeToString([]byte("gcm"))
// 	write(t, env, "KEY="+common.Prefix+ct+common.Sep+gcm+"\n")

// 	origNew := mlkemNewKey
// 	origDecap := mlkemDecapsulate
// 	origAES := aesDecrypt

// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	mlkemDecapsulate = func(_ *mlkem.DecapsulationKey768, _ []byte) ([]byte, error) {
// 		return make([]byte, mlkem.SharedKeySize), nil
// 	}
// 	aesDecrypt = func(_, _ []byte) ([]byte, error) { return []byte("VALUE"), nil }

// 	t.Cleanup(func() {
// 		mlkemNewKey = origNew
// 		mlkemDecapsulate = origDecap
// 		aesDecrypt = origAES
// 	})

// 	out := captureStdout(t, func() {
// 		Unseal([]string{"-in", env, "-priv-file", priv})
// 	})

// 	if !strings.Contains(out, "KEY=VALUE") {
// 		t.Fatalf("expected KEY=VALUE, got: %q", out)
// 	}
// }

// func TestUnseal_SuccessJSON(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")

// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake-priv")))

// 	ct := base64.StdEncoding.EncodeToString([]byte("cipher"))
// 	gcm := base64.StdEncoding.EncodeToString([]byte("gcm"))
// 	write(t, env, "KEY="+common.Prefix+ct+common.Sep+gcm+"\n")

// 	origNew := mlkemNewKey
// 	origDecap := mlkemDecapsulate
// 	origAES := aesDecrypt

// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	mlkemDecapsulate = func(_ *mlkem.DecapsulationKey768, _ []byte) ([]byte, error) {
// 		return make([]byte, mlkem.SharedKeySize), nil
// 	}
// 	aesDecrypt = func(_, _ []byte) ([]byte, error) { return []byte("VALUE"), nil }

// 	t.Cleanup(func() {
// 		mlkemNewKey = origNew
// 		mlkemDecapsulate = origDecap
// 		aesDecrypt = origAES
// 	})

// 	out := captureStdout(t, func() {
// 		Unseal([]string{"-in", env, "-priv-file", priv, "-json"})
// 	})

// 	if !strings.Contains(out, `"KEY":"VALUE"`) {
// 		t.Fatalf("expected JSON output, got: %q", out)
// 	}
// }

// // --- error branches --------------------------------------------------------

// func TestUnseal_MissingPrivFile(t *testing.T) {
// 	env := tmp(t, ".env")
// 	write(t, env, "")

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", "nope"})
// }

// func TestUnseal_InvalidBase64Priv(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, "!!!bad!!!")
// 	write(t, env, "")

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv})
// }

// func TestUnseal_MissingKeys(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))
// 	write(t, env, "A=1\n")

// 	origNew := mlkemNewKey
// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	t.Cleanup(func() { mlkemNewKey = origNew })

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 2)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "MISSING"})
// }

// func TestUnseal_UnsealedValue(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))
// 	write(t, env, "KEY=notsealed\n")

// 	origNew := mlkemNewKey
// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	t.Cleanup(func() { mlkemNewKey = origNew })

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "KEY"})
// }

// func TestUnseal_MalformedSealedValue(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))
// 	write(t, env, "KEY="+common.Prefix+"onlyonepart\n")

// 	origNew := mlkemNewKey
// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	t.Cleanup(func() { mlkemNewKey = origNew })

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "KEY"})
// }

// func TestUnseal_InvalidBase64Ciphertext(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))
// 	write(t, env, "KEY="+common.Prefix+"!!!bad!!!"+common.Sep+"good\n")

// 	origNew := mlkemNewKey
// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	t.Cleanup(func() { mlkemNewKey = origNew })

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "KEY"})
// }

// func TestUnseal_InvalidBase64GCM(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))
// 	write(t, env, "KEY="+common.Prefix+"good"+common.Sep+"!!!bad!!!\n")

// 	origNew := mlkemNewKey
// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	t.Cleanup(func() { mlkemNewKey = origNew })

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "KEY"})
// }

// func TestUnseal_DecapsulationFailure(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))

// 	ct := base64.StdEncoding.EncodeToString([]byte("cipher"))
// 	gcm := base64.StdEncoding.EncodeToString([]byte("gcm"))
// 	write(t, env, "KEY="+common.Prefix+ct+common.Sep+gcm+"\n")

// 	origNew := mlkemNewKey
// 	origDecap := mlkemDecapsulate

// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	mlkemDecapsulate = func(_ *mlkem.DecapsulationKey768, _ []byte) ([]byte, error) {
// 		return nil, fmt.Errorf("decap fail")
// 	}

// 	t.Cleanup(func() {
// 		mlkemNewKey = origNew
// 		mlkemDecapsulate = origDecap
// 	})

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "KEY"})
// }

// func TestUnseal_AESFailure(t *testing.T) {
// 	priv := tmp(t, "priv")
// 	env := tmp(t, ".env")
// 	write(t, priv, base64.StdEncoding.EncodeToString([]byte("fake")))

// 	ct := base64.StdEncoding.EncodeToString([]byte("cipher"))
// 	gcm := base64.StdEncoding.EncodeToString([]byte("gcm"))
// 	write(t, env, "KEY="+common.Prefix+ct+common.Sep+gcm+"\n")

// 	origNew := mlkemNewKey
// 	origDecap := mlkemDecapsulate
// 	origAES := aesDecrypt

// 	mlkemNewKey = func(_ []byte) (*mlkem.DecapsulationKey768, error) { return nil, nil }
// 	mlkemDecapsulate = func(_ *mlkem.DecapsulationKey768, _ []byte) ([]byte, error) {
// 		return make([]byte, mlkem.SharedKeySize), nil
// 	}
// 	aesDecrypt = func(_, _ []byte) ([]byte, error) {
// 		return nil, fmt.Errorf("bad gcm")
// 	}

// 	t.Cleanup(func() {
// 		mlkemNewKey = origNew
// 		mlkemDecapsulate = origDecap
// 		aesDecrypt = origAES
// 	})

// 	code := testutil.StubExit(t, &exitFunc)
// 	defer testutil.ExpectExitPanic(t, code, 1)

// 	Unseal([]string{"-in", env, "-priv-file", priv, "KEY"})
// }
